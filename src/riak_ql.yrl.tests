%% -*- erlang -*-
-include_lib("eunit/include/eunit.hrl").

-define(sql_compilation_assert(String, Expected),
        Exp2 = fix(Expected),
        Toks = riak_ql_lexer:get_tokens(String),
        Got = parse(Toks),
        ?assertEqual({ok, Exp2}, Got)).

-define(where_test(Uncanonical, Expected),
        Got = canonicalise(Uncanonical),
        ?assertEqual(Expected, Got)).

% assert match is useful for only matching part of the output, that
% is being tested and not the whole state to prevent tests failing
% on irrelevant changes.
-define(sql_compilation_assert_match(String, Expected),
        Toks = riak_ql_lexer:get_tokens(String),
        Got = parse(Toks),
        ?assertMatch({ok, Expected}, Got)).

-define(sql_compilation_fail(QL_string),
        Toks = riak_ql_lexer:get_tokens(QL_string),
        Got = parse(Toks),
        ?assertMatch({error, _}, Got)).

fix(#riak_sql_v1{'FROM' = F} = Expected) ->
    case F of
        {regex, _} -> Expected;
        {list,  _} -> Expected;
        _          -> Mod = riak_ql_ddl:make_module_name(F),
                      Expected#riak_sql_v1{helper_mod = Mod}
    end;
fix(Other) ->
    Other.

%% Tests
select_sql_test() ->
    ?sql_compilation_assert("select * from argle",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"argle">>}).

select_quoted_sql_test() ->
    ?sql_compilation_assert("select * from \"argle\"",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"argle">>}).

select_quoted_keyword_sql_test() ->
    ?sql_compilation_assert("select * from \"select\"",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"select">>}).

select_nested_quotes_sql_test() ->
    ?sql_compilation_assert("select * from \"some \"quotes\" in me\"",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"some \"quotes\" in me">>}).

select_regex_sql_test() ->
    ?sql_compilation_assert("select * from /.*/",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = {regex, <<"/.*/">>}}).

select_with_limit_sql_test() ->
    ?sql_compilation_assert("select * from /.*/ limit 1",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = {regex, <<"/.*/">>},
                                         'LIMIT'  = 1}).

select_from_lists_sql_test() ->
    ?sql_compilation_assert("select * from events, errors",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = {list, [<<"events">>, <<"errors">>]}
                                        }).

select_fields_from_lists_sql_test() ->
    ?sql_compilation_assert("select hip, hop, dont, stop from events",
                            #riak_sql_v1{'SELECT' = [[<<"hip">>], [<<"hop">>], [<<"dont">>], [<<"stop">>]],
                                         'FROM'   = <<"events">>
                                        }).

select_where_int_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
                "select value from response_times "
                "where time > '2013-08-12 23:32:01' "
                "and time < int").

select_where_int_type_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
                "select value from response_times "
                "where time > '2013-08-12 23:32:01' "
                "and time < int_type").

select_where_float_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
                "select value from response_times "
                "where time > '2013-08-12 23:32:01' "
                "and time < float").

select_where_float_type_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
                "select value from response_times "
                "where time > '2013-08-12 23:32:01' "
                "and time < float_type").

select_where_timestamp_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
                "select value from response_times "
                "where time > '2013-08-12 23:32:01' "
                "and time < timestamp").

select_where_1_sql_test() ->
    ?sql_compilation_assert("select value from response_times " ++
                                "where time > '2013-08-12 23:32:01' and time < '2013-08-13 12:34:56'",
                            #riak_sql_v1{'SELECT' = [[<<"value">>]],
                                         'FROM'   = <<"response_times">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'<', <<"time">>, {datetime, {{2013, 8, 13}, {12, 34, 56}}}},
                                                      {'>', <<"time">>, {datetime, {{2013, 8, 12}, {23, 32, 1}}}}
                                                     }
                                                    ]
                                        }).

select_where_2_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > now() - 1h limit 1000",
                            #riak_sql_v1{'SELECT' = [[<<"value">>]],
                                         'FROM'   = <<"response_times">>,
                                         'WHERE'  = [
                                                     {'>', <<"time">>, {'-', {<<"now">>, []}, {int, 3600}}}
                                                    ],
                                         'LIMIT'  = 1000
                                        }).

select_where_3_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > 1388534400",
                            #riak_sql_v1{'SELECT' = [[<<"value">>]],
                                         'FROM'   = <<"response_times">>,
                                         'WHERE'  = [
                                                     {'>', <<"time">>, {int, 1388534400}}
                                                    ]
                                        }).

select_where_4_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > 1388534400s",
                            #riak_sql_v1{'SELECT' = [[<<"value">>]],
                                         'FROM'   = <<"response_times">>,
                                         'WHERE'  = [
                                                     {'>', <<"time">>, {int, 1388534400}}
                                                    ]
                                        }).

select_where_5_sql_test() ->
    ?sql_compilation_assert("select * from events where time = 1400497861762723 "++
                                "and sequence_number = 2321",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"sequence_number">>, {int, 2321}},
                                                      {'=', <<"time">>,            {int, 1400497861762723}}
                                                     }
                                                    ]
                                        }).

select_where_6_sql_test() ->
    ?sql_compilation_assert("select * from /^stats\./i where time > now() - 1h",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = {regex, <<"/^stats\./i">>},
                                         'WHERE'  = [
                                                     {'>', <<"time">>, {'-', {<<"now">>, []}, {int, 3600}}}
                                                    ]
                                        }).

select_where_7_sql_test() ->
    ?sql_compilation_assert("select * from /.*/ limit 1",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = {regex, <<"/.*/">>},
                                         'LIMIT'  = 1
                                        }).

select_where_8_sql_test() ->
    ?sql_compilation_assert("select * from events where state = 'NY'",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {'=', <<"state">>, {word, <<"NY">>}}
                                                    ]
                                        }).

select_where_9_sql_test() ->
    ?sql_compilation_assert("select * from log_lines where line =~ /error/i",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"log_lines">>,
                                         'WHERE'  = [
                                                     {'=~', <<"line">>, {regex, <<"/error/i">>}}
                                                    ]
                                        }).

select_where_10_sql_test() ->
    ?sql_compilation_assert("select * from events where customer_id = 23 and type = 'click10'",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"customer_id">>, {int,  23}},
                                                      {'=', <<"type">>,        {word, <<"click10">>}}
                                                     }
                                                    ]
                                        }).

select_where_11_sql_test() ->
    ?sql_compilation_assert("select * from response_times where value > 500",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"response_times">>,
                                         'WHERE'  = [
                                                     {'>', <<"value">>, {int, 500}}
                                                    ]
                                        }).

select_where_12_sql_test() ->
    ?sql_compilation_assert("select * from events where email !~ /.*gmail.*/",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {'!~', <<"email">>, {regex, <<"/.*gmail.*/">>}}
                                                    ]
                                        }).

select_where_13_sql_test() ->
    ?sql_compilation_assert("select * from nagios_checks where status <> 0",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"nagios_checks">>,
                                         'WHERE'  = [
                                                     {'<>', <<"status">>, {int, 0}}
                                                    ]
                                        }).

select_where_14_sql_test() ->
    ?sql_compilation_assert("select * from events where signed_in = false",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {'=', <<"signed_in">>, {word, <<"false">>}}
                                                    ]
                                        }).

select_where_15_sql_test() ->
    ?sql_compilation_assert("select * from events where (email =~ /.*gmail.*/ or " ++
                                "email =~ /.*yahoo.*/) and state = 'ny'",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"state">>, {word, <<"ny">>}},
                                                      {or_,
                                                       {'=~', <<"email">>, {regex, <<"/.*gmail.*/">>}},
                                                       {'=~', <<"email">>, {regex, <<"/.*yahoo.*/">>}}
                                                      }
                                                     }
                                                    ]
                                        }).

select_where_letters_nos_in_strings_1a_test() ->
    ?sql_compilation_assert("select * from events where user = 'user 1'",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {'=', <<"user">>, {word, <<"user 1">>}}
                                                    ]
                                        }).

%% TODO
%%
%% Single quotes don't really work
%%
%% select_where_letters_nos_in_strings_2a_test() ->
%%    ?sql_compilation_assert("select weather from GeoCheckin where time > 2000 and time < 8000 and user = 'user_1'",
%%            #riak_sql_v1{'SELECT' = [["weather"]],
%%                         'FROM'   = <<"GeoCheckin">>,
%%                         'WHERE'  = [
%%                                     {and_,
%%                                      {and_,
%%                                       {'>', "time", {int, 2000}},
%%                                       {'<', "time", {int, 8000}}
%%                                      },
%%                                      {'=', "user", {word, "user_1"}}
%%                                      }
%%                                    ]
%%                        }).

select_where_letters_nos_in_strings_1b_test() ->
    ?sql_compilation_assert("select * from events where user = \"user 1\"",
                            #riak_sql_v1{'SELECT' = [[<<"*">>]],
                                         'FROM'   = <<"events">>,
                                         'WHERE'  = [
                                                     {'=', <<"user">>, {word, <<"user 1">>}}
                                                    ]
                                        }).

select_where_letters_nos_in_strings_2b_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where time > 2000 and time < 8000 and user = \"user_1\"",
                            #riak_sql_v1{'SELECT' = [[<<"weather">>]],
                                         'FROM'   = <<"GeoCheckin">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"user">>, {word, <<"user_1">>}},
                                                      {and_,
                                                       {'<', <<"time">>, {int, 8000}},
                                                       {'>', <<"time">>, {int, 2000}}
                                                      }
                                                     }
                                                    ]
                                        }).

select_where_brackets_1_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where (time > 2000 and time < 8000) and user = \"user_1\"",
                            #riak_sql_v1{'SELECT' = [[<<"weather">>]],
                                         'FROM'   = <<"GeoCheckin">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"user">>, {word, <<"user_1">>}},
                                                      {and_,
                                                       {'<', <<"time">>, {int, 8000}},
                                                       {'>', <<"time">>, {int, 2000}}
                                                      }
                                                     }
                                                    ]
                                        }).

select_where_brackets_2_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where user = \"user_1\" and (time > 2000 and time < 8000)",
                            #riak_sql_v1{'SELECT' = [[<<"weather">>]],
                                         'FROM'   = <<"GeoCheckin">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"user">>, {word, <<"user_1">>}},
                                                      {and_,
                                                       {'<', <<"time">>, {int, 8000}},
                                                       {'>', <<"time">>, {int, 2000}}
                                                      }
                                                     }
                                                    ]
                                        }).

select_where_brackets_2a_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where user = \"user_1\" and (time > 2000 and (time < 8000))",
                            #riak_sql_v1{'SELECT' = [[<<"weather">>]],
                                         'FROM'   = <<"GeoCheckin">>,
                                         'WHERE'  = [
                                                     {and_,
                                                      {'=', <<"user">>, {word, <<"user_1">>}},
                                                      {and_,
                                                       {'<', <<"time">>, {int, 8000}},
                                                       {'>', <<"time">>, {int, 2000}}
                                                      }
                                                     }
                                                    ]
                                        }).

%%
%% canonicalise WHERE clauses tests
%%

canonicalise_where_1_test() ->
    ?where_test({or_,
                 {'<', "alpha", {int, 2}},
                 {'>', "beta",  {int, 3}}
                },
                {or_,
                 {'<', "alpha", {int, 2}},
                 {'>', "beta",  {int, 3}}
                }).

canonicalise_where_2_test() ->
    ?where_test({or_,
                 {'>', "beta",  {int, 3}},
                 {'<', "alpha", {int, 2}}
                },
                {or_,
                 {'<', "alpha", {int, 2}},
                 {'>', "beta",  {int, 3}}
                }).

canonicalise_where_3_test() ->
    ?where_test({and_,
                 {'>', "beta",  {int, 3}},
                 {'<', "alpha", {int, 2}}
                },
                {and_,
                 {'<', "alpha", {int, 2}},
                 {'>', "beta",  {int, 3}}
                }).

canonicalise_where_4_test() ->
    ?where_test({or_,
                 {and_,
                  {'>', "beta",  {int, 3}},
                  {'<', "alpha", {int, 2}}
                 },
                 {'=', "time", {int, 1234}}
                },
                {or_,
                 {'=', "time", {int, 1234}},
                 {and_,
                  {'<', "alpha", {int, 2}},
                  {'>', "beta",  {int, 3}}
                 }
                }).

%%
%% these are the ones that matters
%% all the ands float to the front which means
%% the query rewriter can walk them them and rearange them
%%
canonicalise_where_5_test() ->
    ?where_test({and_,
                 {or_,
                  {'>', "beta",  {int, 3}},
                  {'<', "alpha", {int, 2}}
                 },
                 {and_,
                  {'>', "gamma", {int, 3}},
                  {'<', "delta", {int, 2}}
                 }
                },
                {and_,
                 {'<', "delta", {int, 2}},
                 {and_,
                  {'>', "gamma", {int, 3}},
                  {or_,
                   {'<', "alpha", {int, 2}},
                   {'>', "beta",  {int, 3}}
                  }
                 }
                }).

canonicalise_where_6_test() ->
    ?where_test({and_,
                 {and_,
                  {'>', "beta6",  {int, 3}},
                  {'<', "alpha6", {int, 2}}
                 },
                 {and_,
                  {'>', "gamma6", {int, 3}},
                  {'<', "delta6", {int, 2}}
                 }
                },
                {and_,
                 {'<', "alpha6", {int, 2}},
                 {and_,
                  {'<', "delta6", {int, 2}},
                  {and_,
                   {'>', "beta6",  {int, 3}},
                   {'>', "gamma6", {int, 3}}
                  }
                 }
                }).

canonicalise_where_7_test() ->
    ?where_test({and_,
                 {and_,
                  {or_,
                   {'>', "beta7",  {int, 3}},
                   {'<', "alpha7", {int, 2}}
                  },
                  {and_,
                   {'>', "gamma7", {int, 3}},
                   {'<', "delta7", {int, 2}}
                  }
                 },
                 {and_,
                  {'>', "epsilon7", {int, 3}},
                  {'<', "zeta7",    {int, 2}}
                 }
                },
                {and_,
                 {'<', "delta7", {int, 2}},
                 {and_,
                  {'<', "zeta7", {int, 2}},
                  {and_,
                   {'>', "epsilon7", {int, 3}},
                   {and_,
                    {'>', "gamma7", {int, 3}},
                    {or_,
                     {'<', "alpha7", {int, 2}},
                     {'>', "beta7",  {int, 3}}
                    }
                   }
                  }
                 }
                }).

%%
%% create table tests
%%

create_simple_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
                                "(time timestamp not null, " ++
                                "temperature_k float, " ++
                                "primary key (time))",
                            #ddl_v1{
                               bucket = <<"temperatures">>,
                               fields = [
                                         #riak_field_v1{
                                            name = <<"time">>,
                                            position = 1,
                                            type = timestamp,
                                            optional = false},
                                         #riak_field_v1{
                                            name = <<"temperature_k">>,
                                            position = 2,
                                            type = float,
                                            optional = true}
                                        ],
                               partition_key = #key_v1{
                                                  ast = [#param_v1{
                                                            name = [<<"time">>]
                                                           }]
                                                 },
                               local_key = #key_v1{
                                              ast = [#param_v1{
                                                        name = [<<"time">>]
                                                       }]
                                             }
                              }).

create_simple_sql_int_test() ->
    ?sql_compilation_assert("create table temperatures " ++
                                "(time timestamp not null, " ++
                                "temperature_k int, " ++
                                "primary key (time))",
                            #ddl_v1{
                               bucket = <<"temperatures">>,
                               fields = [
                                         #riak_field_v1{
                                            name = <<"time">>,
                                            position = 1,
                                            type = timestamp,
                                            optional = false},
                                         #riak_field_v1{
                                            name = <<"temperature_k">>,
                                            position = 2,
                                            type = integer,
                                            optional = true}
                                        ],
                               partition_key = #key_v1{
                                              ast = [#param_v1{
                                                        name = [<<"time">>]
                                                       }]
                                                 },
                               local_key = #key_v1{
                                              ast = [#param_v1{
                                                        name = [<<"time">>]
                                                       }]
                                             }
                              }).

create_composite_key_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
                                "(time timestamp not null, " ++
                                "user_id varchar not null, " ++
                                "mytype varchar not null, " ++
                                "primary key ((time, user_id), mytype))",
                            #ddl_v1{
                               bucket = <<"temperatures">>,
                               fields = [
                                         #riak_field_v1{
                                            name = <<"time">>,
                                            position = 1,
                                            type = timestamp,
                                            optional = false},
                                         #riak_field_v1{
                                            name = <<"user_id">>,
                                            position = 2,
                                            type = binary,
                                            optional = false},
                                         #riak_field_v1{
                                            name = <<"mytype">>,
                                            position = 3,
                                            type = binary,
                                            optional = false}
                                        ],
                               partition_key = #key_v1{
                                                  ast = [
                                                         #param_v1{
                                                            name = [<<"time">>]
                                                           },
                                                         #param_v1{
                                                            name = [<<"user_id">>]
                                                           }
                                                        ]},
                               local_key = #key_v1{
                                              ast = [
                                                     #param_v1{
                                                        name = [<<"mytype">>]
                                                       }
                                                    ]}
                              }).

create_no_key_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
                                "(time timestamp not null, " ++
                                "temperature_k float)",
                            #ddl_v1{
                               bucket = <<"temperatures">>,
                               fields = [
                                         #riak_field_v1{
                                            name = <<"time">>,
                                            position = 1,
                                            type = timestamp,
                                            optional = false},
                                         #riak_field_v1{
                                            name = <<"temperature_k">>,
                                            position = 2,
                                            type = float,
                                            optional = true}],
                               partition_key = none,
                               local_key = none
                              }).

%% need to refactor
create_timeseries_sql_test() ->
    String = "CREATE TABLE GeoCheckin "
        ++ "(geohash varchar not null, "
        ++ "user varchar not null, "
        ++ "time timestamp not null, "
        ++ "weather varchar not null, "
        ++ "temperature varchar, "
        ++ "PRIMARY KEY ((geohash, quantum(time, 15, 'm')), time, user))",
    Toks = riak_ql_lexer:get_tokens(String),
    Got = case parse(Toks) of
              {ok, G} -> G;
              _WC     -> wont_compile
          end,
    Expected = #ddl_v1{
                  bucket = <<"GeoCheckin">>,
                  fields = [
                            #riak_field_v1{
                               name = <<"geohash">>,
                               position = 1,
                               type = binary,
                               optional = false},
                            #riak_field_v1{
                               name = <<"user">>,
                               position = 2,
                               type = binary,
                               optional = false},
                            #riak_field_v1{
                               name = <<"time">>,
                               position = 3,
                               type = timestamp,
                               optional = false},
                            #riak_field_v1{
                               name = <<"weather">>,
                               position = 4,
                               type = binary,
                               optional = false},
                            #riak_field_v1{
                               name = <<"temperature">>,
                               position = 5,
                               type = binary,
                               optional = true}
                           ],
                  partition_key = #key_v1{
                                     ast = [
                                            #param_v1{name = [<<"geohash">>]},
                                            #hash_fn_v1{mod  = riak_ql_quanta,
                                                        fn   = quantum,
                                                        args = [
                                                                #param_v1{name = [<<"time">>]}, 15, m
                                                               ],
                                                        type = timestamp}
                                           ]},
                  local_key = #key_v1{
                                 ast = [
                                        #param_v1{name = [<<"time">>]},
                                        #param_v1{name = [<<"user">>]}
                                       ]}
                 },
    ?assertEqual(Expected, Got).

select_sql_case_insensitive_1_test() ->
    ?sql_compilation_assert_match("SELECT * from argle",
                                  #riak_sql_v1{'SELECT' = [[<<"*">>]]}).

select_sql_case_insensitive_2_test() ->
    ?sql_compilation_assert_match("seLEct * from argle",
                                  #riak_sql_v1{'SELECT' = [[<<"*">>]]}).


sql_first_char_is_newline_test() ->
    ?sql_compilation_assert_match("\nselect * from argle",
				  #riak_sql_v1{'SELECT' = [[<<"*">>]]}).

%%%
%%% Failure tests
%%%

failure_sql_test() ->
    String = "klsdafj kljfd (*((*& 89& 8KHH kJHkj hKJH K K",
    Expected = error,
    Got = case parse(riak_ql_lexer:get_tokens(String)) of
              {error, _Err} -> error;
              Other         -> {should_not_compile, Other}
          end,
    ?assertEqual(Expected, Got).

%% select count(type) from events group by time(10m);

%% select count(type) from events group by time(10m), type;

%% select percentile(value, 95) from response_times group by time(30s);

%% select count(type) as number_of_types group by time(10m)

%% select count(type) from events group by time(1h) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(0) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(-1) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(null) where time > now() - 3h

%% select count(type) from events group by time(1h), type fill(0) where time > now() - 3h

%% select count(type) from user_events merge admin_events group by time(10m)

%% select hosta.value + hostb.value from cpu_load as hosta inner join cpu_load as hostb where hosta.host = 'hosta.influxdb.orb' and hostb.host = 'hostb.influxdb.org'

%% select hosta.value + hostb.value from cpu_load as hosta inner join cpu_load as hostb where hosta.host = 'hosta.influxdb.orb' and hostb.host = 'hostb.influxdb.org'

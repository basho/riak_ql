%% -*- erlang -*-
-include_lib("eunit/include/eunit.hrl").

-define(sql_compilation_assert(String, Expected),
	Exp2 = fix(Expected),
	Toks = riak_ql_lexer:get_tokens(String),
	Got = parse(Toks),
	?assertEqual({ok, Exp2}, Got)).

-define(where_test(Uncanonical, Expected), 
	Got = canonicalise(Uncanonical),
	?assertEqual(Expected, Got)).

-define(sql_compilation_fail(QL_string),
	Toks = riak_ql_lexer:get_tokens(QL_string),
	Got = parse(Toks),
	?assertMatch({error, _}, Got)).

fix(#riak_sql_v1{'FROM' = F} = Expected) ->
    case F of
	{regex, _} -> Expected;
	{list,  _} -> Expected;
	_          -> Mod = riak_ql_ddl:make_module_name(F),
		      Expected#riak_sql_v1{helper_mod = Mod}
    end;
fix(Other) ->
    Other.

%% Tests
select_sql_test() ->
    ?sql_compilation_assert("select * from argle",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"argle">>}).

select_quoted_sql_test() ->
    ?sql_compilation_assert("select * from \"argle\"",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"argle">>}).

select_quoted_keyword_sql_test() ->
    ?sql_compilation_assert("select * from \"select\"",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"select">>}).

select_nested_quotes_sql_test() ->
    ?sql_compilation_assert("select * from \"some \"quotes\" in me\"",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"some \"quotes\" in me">>}).

select_regex_sql_test() ->
    ?sql_compilation_assert("select * from /.*/",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = {regex, "/.*/"}}).

select_with_limit_sql_test() ->
    ?sql_compilation_assert("select * from /.*/ limit 1",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = {regex, "/.*/"},
					 'LIMIT'  = 1}).

select_from_lists_sql_test() ->
    ?sql_compilation_assert("select * from events, errors",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = {list, [<<"events">>, <<"errors">>]}
					}).

select_fields_from_lists_sql_test() ->
    ?sql_compilation_assert("select hip, hop, dont, stop from events",
			    #riak_sql_v1{'SELECT' = [["hip"], ["hop"], ["dont"], ["stop"]],
					 'FROM'   = <<"events">>
					}).

select_where_int_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
 		"select value from response_times "
		"where time > '2013-08-12 23:32:01' "
		"and time < int").

select_where_int_type_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
 		"select value from response_times "
		"where time > '2013-08-12 23:32:01' "
		"and time < int_type").

select_where_float_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
 		"select value from response_times "
		"where time > '2013-08-12 23:32:01' "
		"and time < float").

select_where_float_type_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
 		"select value from response_times "
		"where time > '2013-08-12 23:32:01' "
		"and time < float_type").

select_where_timestamp_keyword_not_a_value_sql_test() ->
    ?sql_compilation_fail(
 		"select value from response_times "
		"where time > '2013-08-12 23:32:01' "
		"and time < timestamp").

select_where_1_sql_test() ->
    ?sql_compilation_assert("select value from response_times " ++
				"where time > '2013-08-12 23:32:01' and time < '2013-08-13 12:34:56'",
			    #riak_sql_v1{'SELECT' = [["value"]],
					 'FROM'   = <<"response_times">>,
					 'WHERE'  = [
						     {and_,
						      {'<', "time", {datetime, {{2013, 8, 13}, {12, 34, 56}}}},
						      {'>', "time", {datetime, {{2013, 8, 12}, {23, 32, 1}}}}
						     }
						    ]
					}).

select_where_2_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > now() - 1h limit 1000",
			    #riak_sql_v1{'SELECT' = [["value"]],
					 'FROM'   = <<"response_times">>,
					 'WHERE'  = [
						     {'>', "time", {'-', {"now", []}, {int, 3600}}}
						    ],
					 'LIMIT'  = 1000
					}).

select_where_3_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > 1388534400",
			    #riak_sql_v1{'SELECT' = [["value"]],
					 'FROM'   = <<"response_times">>,
					 'WHERE'  = [
						     {'>', "time", {int, 1388534400}}
						    ]
					}).

select_where_4_sql_test() ->
    ?sql_compilation_assert("select value from response_times where time > 1388534400s",
			    #riak_sql_v1{'SELECT' = [["value"]],
					 'FROM'   = <<"response_times">>,
					 'WHERE'  = [
						     {'>', "time", {int, 1388534400}}
						    ]
					}).

select_where_5_sql_test() ->
    ?sql_compilation_assert("select * from events where time = 1400497861762723 "++
				"and sequence_number = 2321",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {and_, 
						      {'=', "sequence_number", {int, 2321}},
						      {'=', "time",            {int, 1400497861762723}}
						     }
						    ]
					}).

select_where_6_sql_test() ->
    ?sql_compilation_assert("select * from /^stats\./i where time > now() - 1h",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = {regex, "/^stats\./i"},
					 'WHERE'  = [
						     {'>', "time", {'-', {"now", []}, {int, 3600}}}
						    ]
					}).

select_where_7_sql_test() ->
    ?sql_compilation_assert("select * from /.*/ limit 1",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = {regex, "/.*/"},
					 'LIMIT'  = 1
					}).

select_where_8_sql_test() ->
    ?sql_compilation_assert("select * from events where state = 'NY'",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {'=', "state", {word, "NY"}}
						    ]
					}).

select_where_9_sql_test() ->
    ?sql_compilation_assert("select * from log_lines where line =~ /error/i",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"log_lines">>,
					 'WHERE'  = [
						     {'=~', "line", {regex, "/error/i"}}
						    ]
					}).

select_where_10_sql_test() ->
    ?sql_compilation_assert("select * from events where customer_id = 23 and type = 'click10'",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {and_, 
						      {'=', "customer_id", {int,  23}},
						      {'=', "type",        {word, "click10"}}
						     }
						    ]
					}).

select_where_11_sql_test() ->
    ?sql_compilation_assert("select * from response_times where value > 500",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"response_times">>,
					 'WHERE'  = [
						     {'>', "value", {int, 500}}
						    ]
					}).

select_where_12_sql_test() ->
    ?sql_compilation_assert("select * from events where email !~ /.*gmail.*/",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {'!~', "email", {regex, "/.*gmail.*/"}}
						    ]
					}).

select_where_13_sql_test() ->
    ?sql_compilation_assert("select * from nagios_checks where status <> 0",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"nagios_checks">>,
					 'WHERE'  = [
						     {'<>', "status", {int, 0}}
						    ]
					}).

select_where_14_sql_test() ->
    ?sql_compilation_assert("select * from events where signed_in = false",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {'=', "signed_in", {word, "false"}}
						    ]
					}).

select_where_15_sql_test() ->
    ?sql_compilation_assert("select * from events where (email =~ /.*gmail.*/ or " ++
				"email =~ /.*yahoo.*/) and state = 'ny'",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {and_,
						      {'=', "state", {word, "ny"}},
						      {or_,
						       {'=~', "email", {regex, "/.*gmail.*/"}},
						       {'=~', "email", {regex, "/.*yahoo.*/"}}
						      }
						     }
						    ]
					}).

select_where_letters_nos_in_strings_1a_test() ->
    ?sql_compilation_assert("select * from events where user = 'user 1'",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {'=', "user", {word, "user 1"}}
						    ]
					}).

%% TODO
%%
%% Single quotes don't really work
%%
%% select_where_letters_nos_in_strings_2a_test() ->
%%    ?sql_compilation_assert("select weather from GeoCheckin where time > 2000 and time < 8000 and user = 'user_1'",
%% 	      #riak_sql_v1{'SELECT' = [["weather"]],
%% 			   'FROM'   = <<"GeoCheckin">>,
%% 			   'WHERE'  = [
%% 				       {and_,
%% 					{and_,
%% 					 {'>', "time", {int, 2000}},
%% 					 {'<', "time", {int, 8000}}
%% 					},
%% 					{'=', "user", {word, "user_1"}}
%% 					}
%% 				      ]
%% 			  }).

select_where_letters_nos_in_strings_1b_test() ->
    ?sql_compilation_assert("select * from events where user = \"user 1\"",
			    #riak_sql_v1{'SELECT' = [["*"]],
					 'FROM'   = <<"events">>,
					 'WHERE'  = [
						     {'=', "user", {word, "user 1"}}
						    ]
					}).

select_where_letters_nos_in_strings_2b_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where time > 2000 and time < 8000 and user = \"user_1\"",
			    #riak_sql_v1{'SELECT' = [["weather"]],
					 'FROM'   = <<"GeoCheckin">>,
					 'WHERE'  = [
						     {and_,
						      {'=', "user", {word, "user_1"}},
						      {and_,
						       {'<', "time", {int, 8000}},
						       {'>', "time", {int, 2000}}
						      }
						     }
						    ]
					}).

select_where_brackets_1_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where (time > 2000 and time < 8000) and user = \"user_1\"",
			    #riak_sql_v1{'SELECT' = [["weather"]],
					 'FROM'   = <<"GeoCheckin">>,
					 'WHERE'  = [
						     {and_,
						      {'=', "user", {word, "user_1"}},
						      {and_,
						       {'<', "time", {int, 8000}},
						       {'>', "time", {int, 2000}}
						      }
						     }
						    ]
					}).

select_where_brackets_2_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where user = \"user_1\" and (time > 2000 and time < 8000)",
			    #riak_sql_v1{'SELECT' = [["weather"]],
					 'FROM'   = <<"GeoCheckin">>,
					 'WHERE'  = [
						     {and_,
						      {'=', "user", {word, "user_1"}},
						      {and_,
						       {'<', "time", {int, 8000}},
						       {'>', "time", {int, 2000}}
						      }
						     }
						    ]
					}).

select_where_brackets_2a_test() ->
    ?sql_compilation_assert("select weather from GeoCheckin where user = \"user_1\" and (time > 2000 and (time < 8000))",
			    #riak_sql_v1{'SELECT' = [["weather"]],
					 'FROM'   = <<"GeoCheckin">>,
					 'WHERE'  = [
						     {and_,
						      {'=', "user", {word, "user_1"}},
						      {and_,
						       {'<', "time", {int, 8000}},
						       {'>', "time", {int, 2000}}
						      }
						     }
						    ]
					}).

%%
%% canonicalise WHERE clauses tests
%%

canonicalise_where_1_test() ->
    ?where_test({or_, 
		 {'<', "alpha", {int, 2}}, 
		 {'>', "beta",  {int, 3}}
		},
		{or_, 
		 {'<', "alpha", {int, 2}},
		 {'>', "beta",  {int, 3}}
		}).

canonicalise_where_2_test() ->
    ?where_test({or_, 
		 {'>', "beta",  {int, 3}},
		 {'<', "alpha", {int, 2}} 
		},
		{or_, 
		 {'<', "alpha", {int, 2}},
		 {'>', "beta",  {int, 3}}
		}).

canonicalise_where_3_test() ->
    ?where_test({and_, 
		 {'>', "beta",  {int, 3}},
		 {'<', "alpha", {int, 2}} 
		},
		{and_, 
		 {'<', "alpha", {int, 2}},
		 {'>', "beta",  {int, 3}}
		}).

canonicalise_where_4_test() ->
    ?where_test({or_, 
		 {and_, 
		  {'>', "beta",  {int, 3}},
		  {'<', "alpha", {int, 2}} 
		 },
		 {'=', "time", {int, 1234}}
		},
		{or_,
		 {'=', "time", {int, 1234}},
		 {and_, 
		  {'<', "alpha", {int, 2}},
		  {'>', "beta",  {int, 3}}
		 }
		}).

%%
%% these are the ones that matters
%% all the ands float to the front which means
%% the query rewriter can walk them them and rearange them
%%
canonicalise_where_5_test() ->
    ?where_test({and_, 
		 {or_, 
		  {'>', "beta",  {int, 3}},
		  {'<', "alpha", {int, 2}} 
		 },
		 {and_, 
		  {'>', "gamma", {int, 3}},
		  {'<', "delta", {int, 2}} 
		 }
		},
		{and_, 
		 {'<', "delta", {int, 2}},
		 {and_, 
		  {'>', "gamma", {int, 3}},
		  {or_, 
		   {'<', "alpha", {int, 2}},
		   {'>', "beta",  {int, 3}}
		  }
		 }
		}).

canonicalise_where_6_test() ->
    ?where_test({and_, 
		 {and_, 
		  {'>', "beta6",  {int, 3}},
		  {'<', "alpha6", {int, 2}} 
		 },
		 {and_, 
		  {'>', "gamma6", {int, 3}},
		  {'<', "delta6", {int, 2}} 
		 }
		},
		{and_, 
		 {'<', "alpha6", {int, 2}},
		 {and_, 
		  {'<', "delta6", {int, 2}},
		  {and_, 
		   {'>', "beta6",  {int, 3}},
		   {'>', "gamma6", {int, 3}}
		  }
		 }
		}).

canonicalise_where_7_test() ->
    ?where_test({and_, 
		 {and_, 
		  {or_, 
		   {'>', "beta7",  {int, 3}},
		   {'<', "alpha7", {int, 2}} 
		  },
		  {and_, 
		   {'>', "gamma7", {int, 3}},
		   {'<', "delta7", {int, 2}} 
		  }
		 },
		 {and_, 
		  {'>', "epsilon7", {int, 3}},
		  {'<', "zeta7",    {int, 2}} 
		 }
		},
		{and_, 
		 {'<', "delta7", {int, 2}},
		 {and_, 
		  {'<', "zeta7", {int, 2}},
		  {and_,
		   {'>', "epsilon7", {int, 3}},
		   {and_, 
		    {'>', "gamma7", {int, 3}},
		    {or_, 
		     {'<', "alpha7", {int, 2}},
		     {'>', "beta7",  {int, 3}}
		    }
		   }
		  }
		 }
		}).

%%
%% create table tests with foreign key
%%

create_simple_sql_FK_test() ->
    ?sql_compilation_assert("create table temperatures " ++
				"(time timestamp not null, " ++
				"temperature_k float, " ++
				"primary key (time), " ++
				"foreign key (yando, time))",
			    #ddl_v1{
			       bucket = <<"temperatures">>,
			       fields = [
					 #riak_field_v1{
					    name = "time",
					    position = 1,
					    type = timestamp,
					    optional = false},
					 #riak_field_v1{
					    name = "temperature_k",
					    position = 2,
					    type = float,
					    optional = true}
					],	
			       partition_key = #key_v1{
						  ast = [#param_v1{
							    name = ["time"]
							   }]
						 },
			       local_key = #key_v1{
					      ast = [#param_v1{
							name = ["time"]
						       }]
					     },
			       foreign_bucket = "yando",
			       foreign_key    = "time"
			      }).

%%
%% create table tests
%%

create_simple_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
				"(time timestamp not null, " ++
				"temperature_k float, " ++
				"primary key (time))",
			    #ddl_v1{
			       bucket = <<"temperatures">>,
			       fields = [
					 #riak_field_v1{
					    name = "time",
					    position = 1,
					    type = timestamp,
					    optional = false},
					 #riak_field_v1{
					    name = "temperature_k",
					    position = 2,
					    type = float,
					    optional = true}
					],	
			       partition_key = #key_v1{
						  ast = [#param_v1{
							    name = ["time"]
							   }]
						 },
			       local_key = #key_v1{
					      ast = [#param_v1{
							name = ["time"]
						       }]
					     }
			      }).

create_simple_sql_int_test() ->
    ?sql_compilation_assert("create table temperatures " ++
				"(time timestamp not null, " ++
				"temperature_k int, " ++
				"primary key (time))",
			    #ddl_v1{
			       bucket = <<"temperatures">>,
			       fields = [
					 #riak_field_v1{
					    name = "time",
					    position = 1,
					    type = timestamp,
					    optional = false},
					 #riak_field_v1{
					    name = "temperature_k",
					    position = 2,
					    type = integer,
					    optional = true}
					],	
			       partition_key = #key_v1{
					      ast = [#param_v1{
							name = ["time"]
						       }]
						 },
			       local_key = #key_v1{
					      ast = [#param_v1{
							name = ["time"]
						       }]
					     }
			      }).

create_composite_key_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
				"(time timestamp not null, " ++
				"user_id varchar not null, " ++
				"mytype varchar not null, " ++
				"primary key ((time, user_id), mytype))",
			    #ddl_v1{
			       bucket = <<"temperatures">>,
			       fields = [
					 #riak_field_v1{
					    name = "time",
					    position = 1,
					    type = timestamp,
					    optional = false},
					 #riak_field_v1{
					    name = "user_id",
					    position = 2,
					    type = binary,
					    optional = false},
					 #riak_field_v1{
					    name = "mytype",
					    position = 3,
					    type = binary,
					    optional = false}
					],
			       partition_key = #key_v1{
						  ast = [
							 #param_v1{
							    name = ["time"]
							   },
							 #param_v1{
							    name = ["user_id"]
							   }
							]},
			       local_key = #key_v1{
					      ast = [
						     #param_v1{
							name = ["mytype"]
						       }
						    ]}
			      }).

create_no_key_sql_test() ->
    ?sql_compilation_assert("create table temperatures " ++
				"(time timestamp not null, " ++
				"temperature_k float)",
			    #ddl_v1{
			       bucket = <<"temperatures">>,
			       fields = [
					 #riak_field_v1{
					    name = "time",
					    position = 1,
					    type = timestamp,
					    optional = false},
					 #riak_field_v1{
					    name = "temperature_k",
					    position = 2,
					    type = float,
					    optional = true}],
			       partition_key = none,
			       local_key = none
			      }).

%% need to refactor
create_timeseries_sql_test() ->
    String = "CREATE TABLE GeoCheckin "
	++ "(geohash varchar not null, "
	++ "user varchar not null, "
	++ "time timestamp not null, "
	++ "weather varchar not null, "
	++ "temperature varchar, "
	++ "PRIMARY KEY ((geohash, quantum(time, 15, 'm')), time, user))",
    Toks = riak_ql_lexer:get_tokens(String),
    Got = case parse(Toks) of
	      {ok, G} -> G;
	      _WC     -> wont_compile
	  end,
    Expected = #ddl_v1{
		  bucket = <<"GeoCheckin">>,
		  fields = [
			    #riak_field_v1{
			       name = "geohash",
			       position = 1,
			       type = binary,
			       optional = false},
			    #riak_field_v1{
			       name = "user",
			       position = 2,
			       type = binary,
			       optional = false},
			    #riak_field_v1{
			       name = "time",
			       position = 3,
			       type = timestamp,
			       optional = false},
			    #riak_field_v1{
			       name = "weather",
			       position = 4,
			       type = binary,
			       optional = false},
			    #riak_field_v1{
			       name = "temperature",
			       position = 5,
			       type = binary,
			       optional = true}
			   ],
		  partition_key = #key_v1{
				     ast = [
					    #param_v1{name = ["geohash"]},
					    #hash_fn_v1{mod  = riak_ql_quanta,
							fn   = quantum,
							args = [
								#param_v1{name = ["time"]}, 15, m
							       ],
							type = timestamp}
					   ]},
		  local_key = #key_v1{
				 ast = [
					#param_v1{name = ["time"]},
					#param_v1{name = ["user"]}
				       ]}
		 },
    ?assertEqual(Expected, Got).

%%%
%%% Insert Into Query
%%%

simple_insert_sql_test() ->
    ?sql_compilation_assert("INSERT INTO Custs (CustomerName, ContactName) "
			    ++ "VALUES ('Cardinal','Tom B. Erichsen')",
			    #riak_sql_insert_v1{'INSERT INTO' = <<"Custs">>,
						'VALUES'      = [
								{"CustomerName", "Cardinal"},
								 {"ContactName", "Tom B. Erichsen"}
								]}).

simple_join_sql_test() ->
    ?sql_compilation_assert("select * FROM bish INNER JOIN bash ON bish.erk = bash.erk",
			    #riak_sql_v1{'SELECT'     = [["*"]],
					 'FROM'       = <<"bish">>,
					 'INNER JOIN' = <<"bash">>,
					 'ON'         = {"bish.erk", "bash.erk"}}).

%%%
%%% Failure tests
%%%

failure_sql_test() ->
    String = "klsdafj kljfd (*((*& 89& 8KHH kJHkj hKJH K K",
    Expected = error,
    Got = case parse(riak_ql_lexer:get_tokens(String)) of
	      {error, _Err} -> error;
	      Other         -> {should_not_compile, Other}
	  end,
    ?assertEqual(Expected, Got).

%% select count(type) from events group by time(10m);

%% select count(type) from events group by time(10m), type;

%% select percentile(value, 95) from response_times group by time(30s);

%% select count(type) as number_of_types group by time(10m)

%% select count(type) from events group by time(1h) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(0) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(-1) where time > now() - 3h

%% select count(type) from events group by time(1h) fill(null) where time > now() - 3h

%% select count(type) from events group by time(1h), type fill(0) where time > now() - 3h

%% select count(type) from user_events merge admin_events group by time(10m)

%% select hosta.value + hostb.value from cpu_load as hosta inner join cpu_load as hostb where hosta.host = 'hosta.influxdb.orb' and hostb.host = 'hostb.influxdb.org'

%% select hosta.value + hostb.value from cpu_load as hosta inner join cpu_load as hostb where hosta.host = 'hosta.influxdb.orb' and hostb.host = 'hostb.influxdb.org'
